# 数组

Array	length

Collection	size()

List		size()

Set		size()

## 一. 概念及使用

1. 定义
   ​	一个变量只能存一个数据， 如果想要存储多个数据， 就需要通过数组来完成
   ​	同一个类型的数据集合， 数组其实就是一个容器

2. 数组的特点：
   ​    	要求必须存储同一种类型的数据
   ​    	存储时必须要明确元素的个数

3. 实质

   ​	数组 是java 容器中的一种
   ​	数组其实就是存储了固定个数并且必须是同一类型的元素的容器

4. 分类

   ​	一维数组
   ​    二维数组
   ​    多维数组

5. 一维数组 声明的格式

```java
    格式一：
    元素类型[] 数组名 = new 元素类型[元素的个数  或者  数组的长度];

    格式二：
    元素类型[] 数组名 = new 元素类型[]{元素1， 元素2，元素3...};

    简化版
    元素类型[] 数组名 = {元素1， 元素2， 元素3...}；
```
6. 数组中常见的异常

```
    java.lang.ArrayIndexOutOfBoundsException  -- 数组下标越界异常
    java.lang.NullPointerException  -- 空指针异常
```

7. 增强for 循环

```
    for(循环变量的类型 循环变量的名称 ：要遍历的对象){
        循环体内容；
    }

    要遍历的对象： 可以是数组也可以是集合
    循环变量类型:  其实就是数组的 数据类型
    循环变量的名称：可以自定义， 迭代显示的内容 -- 数组中存放的每个数据

    好处： 针对的都是容器， 遍历的过程交由编译器去执行，增强for循环比普通的for 速度快(http://www.cocoachina.com/articles/65360)
    弊端： 在遍历的过程中，不能输出数组的角标
```

8. 求最大值

   定义一个变量， 存目前最大的值
   for 循环遍历， 遇到较大的值， 更改当前记录的最大值
   循环结束后， 就能得到最大的值

9. Arrays类的常用方法：

```java
    1、boolean equals(array1,array2) 
       比较两个数组是否相等。
    
    2、void sort(array) 
	   对数组array的元素进行升序排列
    
    3、String toString(array) 
       把数组array转换成一个字符串。
    
    4、void fill(array,val) 
       把数组array所有元素都赋值为val。
    
    5、int binarySearch(array,val) 
       查询元素值val在数组array中的下标
    
    6、copyof(array,length) 
       把数组array复制成一个长度为length的新数组。
       
	7、属性 Array.length 
	   判断长度
```


## 二. 排序与查找

1. 冒泡排序

```java
	//冒泡排序
	public static void bubbleSortArray(int[] arr){
		//外层循环控制行， 内层循环控制列
		for(int i = 0;i<arr.length-1;i++){
            // -1  防止数组下标越界  ；  -i 依次判断
			for(int j = 0;j<arr.length-1-i;j++){
				if (arr[j] > arr[j+1]) {
					//交换
					ArrayUtils.swap(arr, j, j+1);
				}
			}
		}
	}
```

2. 选择排序

```java
	//选择排序: 选定指定位置和其他位置进行比较， 得到制定位置上的最大值
	public static void selectSortArray(int[] arr){
		
		for(int i = 0; i < arr.length -1; i++){
			for(int j = i+1; j < arr.length; j++){
				if(arr[i] > arr[j]){
					int temp = arr[i];
					arr[i] = arr[j];
					arr[j] = temp;
				}
			}
		}
	}
```

3. 插入排序

```java
	效率最优: https://blog.csdn.net/every__day/article/details/83419170

    public static int[] sortI(int[] ins){
        for (int i = 1; i < ins.length; i ++){
            for (int j = i; j > 0; j --){
                if (ins[j] < ins [j - 1]){
                    int temp = ins[j];
                    ins[j] = ins[j - 1];
                    ins[j - 1] = temp;
                }
            }
        }
        return ins;
    }
```

​	4.二分查找

```java
	public static int binarySearch(int[] arr, int key){
		//定义3个变量： 表示头角标 ， 尾角标， 中间角标
		int min,max,mid;
		
		min = 0;
		max = arr.length-1;
		mid = 0;
		
		//循环的条件， 头角标不能出现在尾角标的后面
		while (min <= max) {
			//获取中间角标
			mid = (min + max) / 2;
			if(key > arr[mid]){
				min = mid + 1;
			}else if (key < arr[mid]) {
				max = mid - 1;
			}else {
				return mid;//找到了， 当前的中间角标
			}
		}
		return -1;
	}
```

## 三. ArrayUntils

```
ArrayUtils中的方法：

1.add():将给定的数据添加到指定的数组中，返回一个新的数组。

2.addAll():合并两个数组。

3.contains():检查该数据在该数组中是否存在，返回一个boolean值。

4.getLength():返回该数组长度。

5.indexOf():从数组的第一位开始查询该数组中是否有指定的数值，存在返回index的数值，否则返回-1。

6.lastIndexOf():从数组的最后一位开始往前查询该数组中是否有指定的数值，存在返回index的数值，否则返回-1。

7.Insert():向指定的位置往该数组添加指定的元素，返回一个新的数组。

8.isEmpty():判断该数组是否为空，返回一个boolean值。

9.isNotEmpty():判断该数组是否为空，而不是null。

10.isSameLength():判断两个数组的长度是否一样，当数组为空视长度为0。返回一个boolean值。

11.isSameType():判断两个数组的类型是否一样，返回一个boolean值。

12.isSorted():判断该数组是否按照自然排列顺序排序，返回一个boolean值。

13.nullToEmpty():

14.remove():删除该数组指定位置上的元素，返回一个新的数组。

15.removeAll():删除指定位置上的元素，返回一个新的数组。

16.removeAllOccurences():从该数组中删除指定的元素，返回一个新的数组。

17.removeElement():从该数组中删除第一次出现的指定元素，返回一个新的数组。

18.removeElements():从该数组中删除指定数量的元素，返回一个新的数组。

19.reverse():数组反转。也可以指定开始和结束的反转位置。

20.subarray():截取数组（包头不包尾），返回一个新的数组。

21.swap():指定该数组的两个位置的元素交换或者指定两个位置后加len的长度元素进行交换。

22.toMap():将数组转换成Map,返回一个map的Object的集合。

23.toObject():将原始数据类型的数组转换成对象类型数组。

24.toPrimitive():将对象类型数组转换成原始数据类型数组。

25.toString():将数组输出为Stirng,返回一个字符串。

26.toStringArray():将Object数组转换为String数组类型。
```

```java
public class ArraryTest {

    public static void main(String[] args) {
        
        int []array={4,5,9};
        
        //add()添加方法结果为：{4,5,9,6}
        int[] newArray=ArrayUtils.add(array, 6);
        System.out.println(ArrayUtils.toString(newArray));
        
        //addAll()方法,结果为：{4,5,9,5,9,6,7}
        int []arrayAll={4,5,9};
        int[] newArrayAll=ArrayUtils.addAll(arrayAll,5,9,6,7);
        System.out.println(ArrayUtils.toString(newArrayAll));
        
        //contains():结果为：true、false
        System.out.println(ArrayUtils.contains(arrayAll, 9));
        System.out.println(ArrayUtils.contains(arrayAll, 3));
        
        //getLength():结果为3
        System.out.println(ArrayUtils.getLength(arrayAll));
        
        //indexOf():2。
        //indexOf(newArrayAll, 9,3):3是指定从哪一位开始查找，返回结果4
        System.out.println(ArrayUtils.indexOf(newArrayAll, 9));
        System.out.println(ArrayUtils.indexOf(newArrayAll, 9,3));
        
        //lastIndexOf()返回结果是4、2
        System.out.println(ArrayUtils.lastIndexOf(newArrayAll, 9));
        System.out.println(ArrayUtils.lastIndexOf(newArrayAll, 9,3));
        
        //insert():结果为{4,5,3,9}
        int [] arr=ArrayUtils.insert(2, arrayAll, 3);
        System.out.println("insert"+ArrayUtils.toString(arr));
        
        //isEmpty():结果为false、true
        int []a=null;
        System.out.println(ArrayUtils.isEmpty(arr));
        System.out.println(ArrayUtils.isEmpty(a));
        
        //isNotEmpty()：结果是false、true
        System.out.println("isNotEmpty:"+ArrayUtils.isNotEmpty(a));
        System.out.println("isNotEmpty:"+ArrayUtils.isNotEmpty(arr));    
        
        //isSorted():结果为false和true
        int[]sort1={5,6,9,1};
        int [] sort2={1,6,8,9};
        System.out.println("sort1:"+ArrayUtils.isSorted(sort1));
        System.out.println("sort2:"+ArrayUtils.isSorted(sort2));
        
        //remove():返回结果为{5,6,1}
        int [] newRe=ArrayUtils.remove(sort1, 2);
        for(int nr:newRe){
            System.out.print(nr);
        }
        
        //reverse():返回new reverse:{1,9,6,5}
        ArrayUtils.reverse(sort1);
        System.out.println("new reverse:"+ArrayUtils.toString(sort1));
        
        //subarray():返回结果subarray:{3,9}
        int[] sub={7,5,3,9,8,4};
        int [] newsub=ArrayUtils.subarray(sub, 2, 4);
        System.out.println("subarray:"+ArrayUtils.toString(newsub));
        
        Object[] subs={7,5,3,9,8,4};
        Map<Object, Object>map=ArrayUtils.toMap(subs);
    }
}
```



# 集合

## 一. 概念

### 1. 集合的由来

　　通常，我们的程序需要根据程序运行时才知道创建多少个对象。但若非程序运行，程序开发阶段，我们根本不知道到底需要多少个数量的对象，甚至不知道它的准确类型。为了满足这些常规的编程需要，我们要求能在任何时候，任何地点创建任意数量的对象，而这些对象用什么来容纳呢？我们首先想到了数组，但是数组只能放统一类型的数据，而且其长度是固定的，那怎么办呢？集合便应运而生了！

### 2. 集合是什么

　　Java集合类存放于 java.util 包中，是一个用来存放对象的容器。

​	注意：

​	    1. 集合只能存放对象。比如你存一个 int 型数据 1放入集合中，其实它是自动转换成 Integer 类后存入的，Java中每一种基本类型都有对应的引用类型。

​		2. 集合存放的是多个对象的引用，对象本身还是放在堆内存中。

​		3. 集合可以存放不同类型，不限数量的数据类型。

### 3. Java 集合框架图

![img](https://images2015.cnblogs.com/blog/1120165/201705/1120165-20170505143634711-1395541187.png)

​	此图来源于：http://blog.csdn.net/u010887744/article/details/50575735



　　发现一个特点，上述所有的集合类，除了 map 系列的集合，即左边集合都实现了 **Iterator** 接口，这是一个用于遍历集合中元素的接口，主要hashNext(),next(),remove()三种方法。它的一个子接口 **ListIterator** 在它的基础上又添加了三种方法，分别是 add(),previous(),hasPrevious()。也就是说如果实现 Iterator 接口，那么在遍历集合中元素的时候，只能往后遍历，被遍历后的元素不会再被遍历到，通常无序集合实现的都是这个接口，比如HashSet；而那些元素有序的集合，实现的一般都是 LinkedIterator接口，实现这个接口的集合可以双向遍历，既可以通过next()访问下一个元素，又可以通过previous()访问前一个 元素，比如ArrayList。

　　还有一个特点就是抽象类的使用。如果要自己实现一个集合类，去实现那些抽象的接口会非常麻烦，工作量很大。这个时候就可以使用抽象类，这些抽象类中给我们提供了许多现成的实现，我们只需要根据自己的需求重写一些方法或者添加一些方法就可以实现自己需要的集合类，工作量大大降低。



## 二. Iterator

### 1. Iterator概念

​	Iterator是Java集合的顶层接口（不包括 map 系列的集合，Map接口 是 map 系列集合的顶层接口）

主要方法:

```java
	Object next()：返回迭代器刚越过的元素的引用，返回值是 Object，需要强制转换成自己需要的类型

	boolean hasNext()：判断容器内是否还有可供访问的元素

	void remove()：删除迭代器刚越过的元素
```

​	所有除了 map 系列的集合，我们都能通过迭代器来对集合中的元素进行遍历。

### 2. Iterator与Iterable

​	注意：我们可以在源码中追溯到集合的顶层接口，比如 Collection 接口，可以看到它继承的是类 Iterable

![img](https://images2015.cnblogs.com/blog/1120165/201703/1120165-20170315161812151-117827845.png)

​	那这就得说明一下 Iterator 和 Iterable 的区别：

​	 Iterable ：存在于 java.lang 包中。

　　　　![img](https://images2015.cnblogs.com/blog/1120165/201703/1120165-20170315162024541-482452136.png)

​	我们可以看到，里面封装了 Iterator 接口。所以只要实现了只要实现了Iterable接口的类，就可以使用Iterator迭代器了。

​	Iterator ：存在于 java.util 包中。核心的方法next(),hasnext(),remove()。

 	这里我们引用一个Iterator 的实现类 ArrayList 来看一下迭代器的使用：暂时先不管 List 集合是什么，只需要看看迭代器的用法就行了

```java
 1         //产生一个 List 集合，典型实现为 ArrayList。
 2         List list = new ArrayList();
 3         //添加三个元素
 4         list.add("Tom");
 5         list.add("Bob");
 6         list.add("Marry");
 7         //构造 List 的迭代器
 8         Iterator it = list.iterator();
 9         //通过迭代器遍历元素
10         while(it.hasNext()){
11             Object obj = it.next();
12             System.out.println(obj);
13         }
```

##  三. Collection

​	List 接口和 Set 接口的父接口

　　　　![img](https://images2015.cnblogs.com/blog/1120165/201703/1120165-20170315163013854-1249426924.png)

　　看一下 Collection 集合的使用例子：

```java
 1         //我们这里将 ArrayList集合作为 Collection 的实现类
 2         Collection collection = new ArrayList();
 3         
 4         //添加元素
 5         collection.add("Tom");
 6         collection.add("Bob");
 7         
 8         //删除指定元素
 9         collection.remove("Tom");
10         
11         //删除所有元素
12         Collection c = new ArrayList();
13         c.add("Bob");
14         collection.removeAll(c);
15         
16         //检测是否存在某个元素
17         collection.contains("Tom");
18         
19         //判断是否为空
20         collection.isEmpty();
21         
22         //利用增强for循环遍历集合
23         for(Object obj : collection){
24             System.out.println(obj);
25         }
26         //利用迭代器 Iterator
27         Iterator iterator = collection.iterator();
28         while(iterator.hasNext()){
29             Object obj = iterator.next();
30             System.out.println(obj);
31         }
32
33			System.out.println( collection.size() );
```

## 四. List 

### 1. 概念

​	有序，可以重复的集合。

　　![img](https://images2015.cnblogs.com/blog/1120165/201703/1120165-20170315164917916-1891467256.png)

​	由于 List 接口是继承于 Collection 接口，所以基本的方法如上所示。

​	List 接口的三个典型实现：

　  	1、List list1 = new ArrayList();

　　　　底层数据结构是数组，查询快，增删慢;线程不安全，效率高

 　  2、List list2 = new Vector();

　　　　底层数据结构是数组，查询快，增删慢;线程安全，效率低,几乎已经淘汰了这个集合

　   3、List list3 = new LinkedList();

　　　　底层数据结构是链表，查询慢，增删快;线程不安全，效率高

### 2.ArrayList

#### 1、ArrayList常见API

| 修饰符和类型    | 方法和描述                                                   |
| --------------- | ------------------------------------------------------------ |
| boolean         | add(E e)   将指定的元素追加到此列表的末尾。                  |
| void            | add(int index, E element)    将指定元素插入此列表中的指定位置。 |
| boolean         | addAll(Collection<? extends E> c)     将指定集合中的所有元素按指定集合的迭代器返回的顺序附加到此列表的末尾。 |
| boolean         | addAll(int index, Collection<? extends E> c)     从指定位置开始，将指定集合中的所有元素插入此列表。 |
| void            | clear()     从此列表中删除所有元素。                         |
| Object          | clone()    返回此 ArrayList 实例的浅表副本。                 |
| boolean         | contains(Object o)    如果此列表包含指定的元素，则返回 true 。 |
| void            | ensureCapacity(int minCapacity)    如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。 |
| void            | forEach(Consumer<? super E> action)    对每个元素执行给定操作， Iterable  直到处理完所有元素或操作引发异常。 |
| E               | get(int index)    返回此列表中指定位置的元素。               |
| int             | indexOf(Object o)    返回此列表中第一次出现的指定元素的索引，如果此列表不包含该元素，则返回-1。 |
| boolean         | isEmpty()    如果此列表不包含任何元素，则返回 true 。        |
| Iterator<E>     | iterator()    以适当的顺序返回此列表中元素的迭代器。         |
| int             | lastIndexOf(Object o)    返回此列表中指定元素最后一次出现的索引，如果此列表不包含该元素，则返回-1。 |
| ListIterator<E> | listIterator()    返回此列表中元素的列表迭代器（按正确顺序）。 |
| ListIterator<E> | listIterator(int index)    从列表中的指定位置开始，返回列表中元素的列表迭代器（按正确顺序）。 |
| E               | remove(int index)    删除此列表中指定位置的元素。            |
| boolean         | remove(Object o)    从此列表中删除指定元素的第一个匹配项（如果存在）。 |
| boolean         | removeAll(Collection<?> c)    从此列表中删除指定集合中包含的所有元素。 |
| boolean         | removeIf(Predicate<? super E> filter)    删除此集合中满足给定谓词的所有元素。 |
| protected void  | removeRange(int fromIndex, int toIndex)    从此列表中删除索引介于其中 fromIndex ，包括和 toIndex 不包含的所有元素 。 |
| void            | replaceAll(UnaryOperator<E> operator)    将该列表的每个元素替换为将运算符应用于该元素的结果。 |
| boolean         | retainAll(Collection<?> c)    仅保留此列表中包含在指定集合中的元素。 |
| E               | set(int index, E element)    用指定的元素替换此列表中指定位置的元素。 |
| int             | size()    返回此列表中的元素数。                             |
| void            | sort(Comparator<? super E> c)    根据指定的顺序对此列表进行排序 [ Comparator ](https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html)。 |
| Spliterator<E>  | spliterator()    在此列表中的元素上创建*后期绑定* 和*失败快速* [ Spliterator ](https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html)。 |
| List<E>         | subList(int fromIndex, int toIndex)    返回指定的 fromIndex ，包含的和 toIndex 独占的列表部分的视图 。 |
| Object[]        | toArray()    以适当的顺序（从第一个元素到最后一个元素）返回包含此列表中所有元素的数组。 |
| <T> T[]         | toArray(T[] a)    以适当的顺序返回包含此列表中所有元素的数组（从第一个元素到最后一个元素）; 返回数组的运行时类型是指定数组的运行时类型。 |
| void            | trimToSize()    将此 ArrayList 实例的容量调整为列表的当前大小。 |

#### 2、比较秀的用法

```java
	public void testList() {
        List<String> list = new ArrayList<>();
        list.add("hello");
        list.add("world");
        list.add("java");
        list.add("python");
        list.add("php");

        // 选择删除
        list.removeIf(new Predicate<String>() {
            @Override
            public boolean test(String t) {
                return t.length() > 4;
            }
        });

        // lambda表达式
        list.removeIf(s -> s.equals("java"));

        // 使用迭代器遍历
        Iterator<String> iterator = list.iterator();
        iterator.forEachRemaining(new Consumer<String>() {
            @Override
            public void accept(String t) {
                System.out.println(t);
            }
        });
        iterator.forEachRemaining(System.out::println);
        // 输出list
        list.stream().forEach(s -> System.out.println(s));

        // list转换为字符串数组
        String[] arr = list.toArray(new String[0]);
        Arrays.stream(arr).forEach(System.out::println);

        //强大的ListIterator
        ListIterator<String> lIterator = list.listIterator();
        while (lIterator.hasNext()) {
            System.out.println(lIterator.next());
            lIterator.add("Go");
        }
        lIterator.forEachRemaining(System.out::println);
    }
```

#### 3、List去重

```java
一、String去重：

    //set集合去重，不改变原有的顺序
    public static void pastLeep1(List<String> list){
        System.out.println("list = [" + list.toString() + "]");
        List<String> listNew=new ArrayList<>();
        Set set=new HashSet();
        for (String str:list) {
            if(set.add(str)){
                listNew.add(str);
            }
        }
        System.out.println("listNew = [" + listNew.toString() + "]");
    }

    //遍历后判断赋给另一个list集合
    public static void pastLeep2(List<String> list){
        System.out.println("list = [" + list.toString() + "]");
        List<String> listNew=new ArrayList<>();
        for (String str:list) {
            if(!listNew.contains(str)){
                listNew.add(str);
            }
        }
        System.out.println("listNew = [" + listNew.toString() + "]");
    }

    //set去重
    public static void pastLeep3(List<String> list){
        System.out.println("list = [" + list + "]");
        Set set = new HashSet();
        List<String> listNew=new ArrayList<>();
        set.addAll(list);
        listNew.addAll(set);
        System.out.println("listNew = [" + listNew + "]");
    }

    //set去重（缩减为一行）
    public static void pastLeep4(List<String> list){
        System.out.println("list = [" + list + "]");
        List<String> listNew=new ArrayList<>(new HashSet(list));
        System.out.println("listNew = [" + listNew + "]");
    }

    //去重并按自然顺序排序
    public static void pastLeep5(List<String> list){
        System.out.println("list = [" + list + "]");
        List<String> listNew=new ArrayList<>(new TreeSet<String>(list));
        System.out.println("listNew = [" + listNew + "]");
    }


二、对象去重方法：
package com.hcycom.iams.ncolog;

import java.util.*;
import static java.util.Comparator.comparingLong;
import static java.util.stream.Collectors.collectingAndThen;
import static java.util.stream.Collectors.toCollection;

public class Test {

    public static void main(String[] args) {
        Data data1 = new Data(1,"aaaa");
        Data data2 = new Data(2,"dddd");
        Data data3 = new Data(1,"vvvv");
        Data data4 = new Data(4,"rrrr");
        Data data5 = new Data(1,"ssss");
        List<Data> list = Arrays.asList(data1,data2,data3,data4,data5);
        List<Data> l = test2(list);
        System.out.println(Arrays.toString(l.toArray()));

    }

    //对象去重
    public static List<Data> test2(List<Data> list){
        List<Data> unique = list.stream().collect(
                collectingAndThen(
                        toCollection(() -> new TreeSet<>(comparingLong(Data::getId))), ArrayList::new)
        );
        return unique;
    }
}

// 实体对象
class Data{

    private int id;
    private String name;

    public Data(int id, String name) {
        this.id = id;
        this.name = name;
    }
}
```

### 3.LinkedList

#### 1、LinkedList常见API

| 修饰符和类型    | 方法和描述                                                   |
| --------------- | ------------------------------------------------------------ |
| boolean         | add(E e)    将指定的元素追加到此列表的末尾。                 |
| void            | add(int index, E element)    将指定元素插入此列表中的指定位置。 |
| boolean         | addAll(Collection<? extends E> c)    将指定集合中的所有元素按指定集合的迭代器返回的顺序附加到此列表的末尾。 |
| boolean         | addAll(int index, Collection<? extends E> c)    从指定位置开始，将指定集合中的所有元素插入此列表。 |
| void            | addFirst(E e)    在此列表的开头插入指定的元素。              |
| void            | addLast(E e)    将指定的元素追加到此列表的末尾。             |
| void            | clear()    从此列表中删除所有元素。                          |
| Object          | clone()    返回此的浅表副本 LinkedList 。                    |
| boolean         | contains(Object o)     true 如果此列表包含指定的元素，则返回。 |
| Iterator<E>     | descendingIterator()    以相反的顺序返回此双端队列中元素的迭代器。 |
| E               | element()    检索但不删除此列表的头部（第一个元素）。        |
| E               | get(int index)    返回此列表中指定位置的元素。               |
| E               | getFirst()    返回此列表中的第一个元素。                     |
| E               | getLast()     返回此列表中的最后一个元素。                   |
| int             | indexOf(Object o)    返回此列表中第一次出现的指定元素的索引，如果此列表不包含该元素，则返回-1。 |
| int             | lastIndexOf(Object o)    返回此列表中指定元素最后一次出现的索引，如果此列表不包含该元素，则返回-1。 |
| ListIterator<E> | listIterator(int index)    从列表中的指定位置开始，返回此列表中元素的列表迭代器（按正确顺序）。 |
| boolean         | offer(E e)    将指定的元素添加为此列表的尾部（最后一个元素）。 |
| boolean         | offerFirst(E e)    在指定列表的前面插入指定的元素。          |
| boolean         | offerLast(E e)    在此列表的末尾插入指定的元素。             |
| E               | peek()    检索但不删除此列表的头部（第一个元素）。           |
| E               | peekFirst()    检索但不删除此列表的第一个元素， null 如果此列表为空，则返回。 |
| E               | peekLast()    检索但不删除此列表的最后一个元素， null 如果此列表为空，则返回。 |
| E               | poll()    检索并删除此列表的头部（第一个元素）。             |
| E               | pollFirst()    检索并删除此列表的第一个元素， null 如果此列表为空，则返回。 |
| E               | pollLast()    检索并删除此列表的最后一个元素， null 如果此列表为空，则返回。 |
| E               | pop()    弹出此列表所代表的堆栈中的元素。                    |
| void            | push(E e)    将元素推送到此列表所表示的堆栈上。              |
| E               | remove()    检索并删除此列表的头部（第一个元素）。           |
| E               | remove(int index)    删除此列表中指定位置的元素。            |
| boolean         | remove(Object o)    从此列表中删除指定元素的第一个匹配项（如果存在）。 |
| E               | removeFirst()    从此列表中删除并返回第一个元素。            |
| boolean         | removeFirstOccurrence(Object o)    删除此列表中第一次出现的指定元素（从头到尾遍历列表时）。 |
| E               | removeLast()    从此列表中删除并返回最后一个元素。           |
| boolean         | removeLastOccurrence(Object o)    删除此列表中最后一次出现的指定元素（从头到尾遍历列表时）。 |
| E               | set(int index, E element)    用指定的元素替换此列表中指定位置的元素。 |
| int             | size()    返回此列表中的元素数。                             |
| Spliterator<E>  | spliterator()    在此列表中的元素上创建*后期绑定* 和*失败快速* [ Spliterator ](https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html)。 |
| Object[]        | toArray()    以适当的顺序（从第一个元素到最后一个元素）返回包含此列表中所有元素的数组。 |
| <T> T[]         | toArray(T[] a)    以适当的顺序返回包含此列表中所有元素的数组（从第一个元素到最后一个元素）; 返回数组的运行时类型是指定数组的运行时类型。 |



## 五.  Set

​	典型实现 Set() 是一个无序，不可重复的集合

### 1.HashSet 

#### 1、HashSet常见API

| 修饰符和类型   | 方法和描述                                                   |
| -------------- | ------------------------------------------------------------ |
| boolean        | add(E e)    如果指定的元素尚不存在，则将其添加到此集合中。   |
| void           | clear()    删除此集合中的所有元素。                          |
| Object         | clone()   返回此HashSet实例的浅表副本：未克隆元素本身。      |
| boolean        | contains(Object o)     如果此set包含指定的元素，则返回 true。 |
| boolean        | isEmpty()    如果此set不包含任何元素，则返回 true。          |
| Iterator<E>    | iterator()    返回此set中元素的迭代器。                      |
| boolean        | remove(Object o)    如果存在，则从该集合中移除指定的元素。   |
| int            | size()    返回此集合中的元素数（其基数）。                   |
| Spliterator<E> | spliterator()    在此集合中的元素上创建*后期绑定* 和*失败快速* [`Spliterator`](https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html)。 |

#### 2、HashSet概念及使用

​	**Set hashSet = new HashSet();**

```
	HashSet:不能保证元素的顺序；不可重复；不是线程安全的；集合元素可以为 NULL;
	
	其底层其实是一个数组，存在的意义是加快查询速度。我们知道在一般的数组中，元素在数组中的索引位置是随机的，元素的取值和元素的位置之间不存在确定的关系，因此，在数组中查找特定的值时，需要把查找值和一系列的元素进行比较，此时的查询效率依赖于查找过程中比较的次数。而 HashSet 集合底层数组的索引和值有一个确定的关系：index=hash(value),那么只需要调用这个公式，就能快速的找到元素或者索引。
```

　　对于 HashSet: 如果两个对象通过 equals() 方法返回 true，这两个对象的 hashCode 值也应该相同。

```
1、当向HashSet集合中存入一个元素时，HashSet会先调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据hashCode值决定该对象在HashSet中的存储位置

	1.1、如果 hashCode 值不同，直接把该元素存储到 hashCode() 指定的位置
	
	1.2、如果 hashCode 值相同，那么会继续判断该元素和集合对象的 equals() 作比较
	
		1.2.1、hashCode 相同，equals 为 true，则视为同一个对象，不保存在 hashSet（）中
		
		1.2.2、hashCode 相同，equals 为 false，则存储在之前对象同槽位的链表上，这非常麻烦，我们应该约束这种情况，即保证：如果两个对象通过 equals() 方法返回 true，这两个对象的 hashCode 值也应该相同。
		
		
	注意：每一个存储到 哈希 表中的对象，都得提供 hashCode() 和 equals() 方法的实现，用来判断是否是同一个对象
	对于 HashSet 集合，我们要保证如果两个对象通过 equals() 方法返回 true，这两个对象的 hashCode 值也应该相同。
```

#### 3、LinkedHashSet

​	**Set linkedHashSet = new LinkedHashSet();**

```
	不可以重复，有序
	因为底层采用 链表 和 哈希表的算法。链表保证元素的添加顺序，哈希表保证元素的唯一性
```



###  2.TreeSet

#### 1、TreeSet概念

​	**Set treeSet = new TreeSet();**

```java
	TreeSet:有序；不可重复，底层使用 红黑树算法，擅长于范围查询。

	如果使用 TreeSet() 无参数的构造器创建一个 TreeSet 对象, 则要求放入其中的元素的类必须实现 Comparable 接口所以, 在其中不能放入 null 元素

	必须放入同样类的对象*.(默认会进行排序) 否则可能会发生类型转换异常.我们可以使用泛型来进行限制
```

#### 2、TreeSet常见API

|     修饰符和类型      | 方法和描述                                                   |
| :-------------------: | ------------------------------------------------------------ |
|        boolean        | add(E e)   如果指定的元素尚不存在，则将其添加到此集合中。    |
|        boolean        | addAll(Collection<? extends E> c)   将指定集合中的所有元素添加到此集合中。 |
|           E           | ceiling(E e)   返回此set中大于或等于给定元素的最小元素，或者 null 如果没有这样的元素。 |
|         void          | clear()   删除此集合中的所有元素。                           |
|        Object         | clone()   返回此 TreeSet 实例的浅表副本。                    |
| Comparator<? super E> | comparator()   返回用于对此set中的元素进行排序的比较器，如果此set使用其元素的[自然顺序](https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html)，则返回 null 。 |
|        boolean        | contains(Object o)    true 如果此set包含指定的元素，则返回。 |
|      Iterator<E>      | descendingIterator()   以降序返回此集合中元素的迭代器。      |
|    NavigableSet<E>    | descendingSet()   返回此set中包含的元素的逆序视图。          |
|           E           | first()   返回此set中当前的第一个（最低）元素。              |
|           E           | floor(E e)   返回此set中小于或等于给定元素的最大元素，或者 null 如果没有这样的元素。 |
|     SortedSet<E>      | headSet(E toElement)   返回此set的部分视图，其元素严格小于 toElement 。 |
|    NavigableSet<E>    | headSet(E toElement, boolean inclusive)   返回此set的部分视图，其元素小于（或等于，如果 inclusive 为true） toElement 。 |
|           E           | higher(E e)   返回此集合中的最小元素严格大于给定元素，或者 null 如果没有这样的元素。 |
|        boolean        | isEmpty()    true 如果此set不包含任何元素，则返回            |
|      Iterator<E>      | iterator()   以升序返回此集合中元素的迭代器。                |
|           E           | last()   返回此集合中当前的最后一个（最高）元素。            |
|           E           | lower(E e)   返回此集合中的最大元素严格小于给定元素，或者 null 如果没有这样的元素。 |
|           E           | pollFirst()   检索并删除第一个（最低）元素， null 如果此组为空，则返回。 |
|           E           | pollLast()   检索并删除最后一个（最高）元素， null 如果此集合为空，则返回。 |
|        boolean        | remove(Object o)   如果存在，则从该集合中移除指定的元素。    |
|          int          | size()   返回此集合中的元素数（其基数）。                    |
|    Spliterator<E>     | spliterator()   在此集合中的元素上创建*后期绑定* 和*失败快速* [ Spliterator ](https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html)。 |
|    NavigableSet<E>    | subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)   返回此set的部分视图，其元素范围为  fromElement to  toElement 。 |
|     SortedSet<E>      | subSet(E fromElement, E toElement)   返回此set的部分视图，其元素范围从 fromElement （包括）到 toElement （不包括）。 |
|     SortedSet<E>      | tailSet(E fromElement)   返回此set的部分视图，其元素大于或等于 fromElement 。 |
|    NavigableSet<E>    | tailSet(E fromElement, boolean inclusive)   返回此set的部分视图，其元素大于（或等于，如果 inclusive 为true） fromElement 。 |

#### 3、TreeSet使用

```java
	Set treeSet = new TreeSet();
    treeSet.add(1);  //添加一个 Integer 类型的数据
    treeSet.add("a");   //添加一个 String 类型的数据
    System.out.println(treeSet);  //会报类型转换异常的错误
```

　　![img](https://images2015.cnblogs.com/blog/1120165/201705/1120165-20170509004119019-1767190549.png)

#### 4、自然排序

```
	添加自定义对象的时候，必须要实现 Comparable 接口，并要覆盖 compareTo(Object obj) 方法来自定义比较规则
	
	如果 this > obj,返回正数 1
	如果 this < obj,返回负数 -1
	如果 this = obj,返回 0 ，则认为这两个对象相等

 	两个对象通过 Comparable 接口 compareTo(Object obj) 方法的返回值来比较大小, 并进行升序排列
```

![](https://images2015.cnblogs.com/blog/1120165/201705/1120165-20170509081622488-1398934456.png)

#### 5、定制排序:

```
	创建 TreeSet 对象时, 传入 Comparator 接口的实现类. 要求: Comparator 接口的 compare 方法的返回值和 两个元素的 equals() 方法具有一致的返回值  

	当需要把一个对象放入 TreeSet 中，重写该对象对应的 equals() 方法时，应保证该方法与 compareTo(Object obj) 方法有一致的结果
```

```java
public class TreeSetTest {
    public static void main(String[] args) {
        Person p1 = new Person(1);
        Person p2 = new Person(2);
        Person p3 = new Person(3);
         
        Set<Person> set = new TreeSet<>(new Person());
        set.add(p1);
        set.add(p2);
        set.add(p3);
        System.out.println(set);  //结果为[1, 2, 3]
    }
}
 
class Person implements Comparator<Person>{
    public int age;
    public Person(){}
    public Person(int age){
        this.age = age;
    }
    @Override
    /***
     * 根据年龄大小进行排序
     */
    public int compare(Person o1, Person o2) {
        // TODO Auto-generated method stub
        if(o1.age > o2.age){
            return 1;
        }else if(o1.age < o2.age){
            return -1;
        }else{
            return 0;
        }
    }
     
    @Override
    public String toString() {
        // TODO Auto-generated method stub
        return ""+this.age;
    }
}
```

### 3.三个 Set 接口的实现类比较

共同点：
​	1、都不允许元素重复
​	2、都不是线程安全的类，解决办法：Set set = Collections.synchronizedSet(set 对象)

不同点：
​	HashSet: 不保证元素的添加顺序，底层采用 哈希表算法，查询效率高。判断两个元素是否相等，equals() 方法返回 true,hashCode() 值相等。即要求存入 HashSet 中的元素要覆盖 equals() 方法和 hashCode()方法

​	LinkedHashSet: HashSet 的子类，底层采用了 哈希表算法以及 链表算法，既保证了元素的添加顺序，也保证了查询效率。但是整体性能要低于 HashSet

​	TreeSet: 不保证元素的添加顺序，但是会对集合中的元素进行排序。底层采用 红-黑 树算法（树结构比较适合范围查询）

 

## 六. Map

### 1.Map概念及使用

**1.概念:**

​	key-value 的键值对，key 不允许重复，value 可以

　　1、严格来说 Map 并不是一个集合，而是两个集合之间 的映射关系。

　	2、这两个集合每一条数据通过映射关系，我们可以看成是一条数据。即 Entry(key,value）。Map 可以看成是由多个 Entry 组成。

　　3、因为 Map 集合即没有实现于 Collection 接口，也没有实现 Iterable 接口，所以不能对 Map 集合进行 for-each 遍历。　　　

　　　　　　　　　　　　![img](https://images2015.cnblogs.com/blog/1120165/201705/1120165-20170509215438113-1495103512.png)

**2.使用:**

```java
		Map<String,Object> hashMap = new HashMap<>();
        //添加元素到 Map 中
        hashMap.put("key1", "value1");
        hashMap.put("key2", "value2");
        hashMap.put("key3", "value3");
        hashMap.put("key4", "value4");
        hashMap.put("key5", "value5");
         
        //删除 Map 中的元素,通过 key 的值
        hashMap.remove("key1");
         
        //通过 get(key) 得到 Map 中的value
        Object str1 = hashMap.get("key1");
         
        //可以通过 添加 方法来修改 Map 中的元素
        hashMap.put("key2", "修改 key2 的 Value");
         
        //通过 map.values() 方法得到 Map 中的 value 集合
        Collection<Object> value = hashMap.values();
        for(Object obj : value){
            //System.out.println(obj);
        }
         
        //通过 map.keySet() 得到 Map 的key 的集合，然后 通过 get(key) 得到 Value
        Set<String> set = hashMap.keySet();
        for(String str : set){
            Object obj = hashMap.get(str);
            //System.out.println(str+"="+obj);
        }
         
        //通过 Map.entrySet() 得到 Map 的 Entry集合，然后遍历
        Set<Map.Entry<String, Object>> entrys = hashMap.entrySet();
        for(Map.Entry<String, Object> entry: entrys){
            String key = entry.getKey();
            Object value2 = entry.getValue();
            System.out.println(key+"="+value2);
        }
         
        System.out.println(hashMap);
```

**3.Map 的常用实现类：**

　　　　　　　　![img](https://images2015.cnblogs.com/blog/1120165/201705/1120165-20170509224035660-1080038371.png)

### 2.HashMap

#### 1、HashMap构造函数摘要

|                    构造函数                    | 描述                                                         |
| :--------------------------------------------: | ------------------------------------------------------------ |
|                   HashMap()                    | 使用默认初始容量（16）和默认加载因子（0.75）构造一个空的 HashMap 。 |
|          HashMap(int initialCapacity)          | 使用指定的初始容量和默认加载因子（0.75）构造一个空的 HashMap 。 |
| HashMap(int initialCapacity, float loadFactor) | 使用指定的初始容量和加载因子构造一个空的 HashMap 。          |
|    HashMap(Map<? extends K,? extends V> m)     | 使用与指定 Map 相同的映射构造一个新的 HashMap 。             |

#### 2、HashMap常见API

| 修饰符和类型          | 方法和描述                                                   |
| --------------------- | ------------------------------------------------------------ |
|  void                 |  clear() 从此映射中删除所有映射。                            |
|  Object               |  clone() 返回此 HashMap 实例的浅表副本：未克隆键和值本身。   |
|  V                    |  compute(K key, BiFunction<? super K,? super V,? extends V> remappingFunction) 尝试计算指定键及其当前映射值的映射（或者 null 如果没有当前映射）。 |
|  V                    |  computeIfAbsent(K key, Function<? super K,? extends V> mappingFunction) 如果指定的键尚未与值相关联（或映射到 null ），则尝试使用给定的映射函数计算其值，并将其输入此映射，除非 null 。 |
|  V                    |  computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> remappingFunction) 如果指定键的值存在且为非null，则尝试在给定键及其当前映射值的情况下计算新映射。 |
|  boolean              |  containsKey(Object key) 如果此映射包含指定键的映射，则返回 true 。 |
|  boolean              |  containsValue(Object value) 如果此映射将一个或多个键映射到指定值，则返回 true 。 |
|  Set<Map.Entry<K,V>>  |  entrySet() 返回[ Set ](https://docs.oracle.com/javase/8/docs/api/java/util/Set.html)此映射中包含的映射的视图。 |
|  void                 |  forEach(BiConsumer<? super K,? super V> action) 对此映射中的每个条目执行给定操作，直到处理完所有条目或操作引发异常。 |
|  V                    |  get(Object key) 返回指定键映射到的值，或者 null 此映射是否不包含键的映射。 |
|  V                    |  getOrDefault(Object key, V defaultValue) 返回指定键映射到的值，或者  defaultValue 此映射是否不包含键的映射。 |
|  boolean              |  isEmpty() 如果此映射不包含键 - 值映射，则返回 true 。       |
|  Set<K>               |  keySet() 返回[ Set ](https://docs.oracle.com/javase/8/docs/api/java/util/Set.html)此映射中包含的键的视图。 |
|  V                    |  merge(K key, V value, BiFunction<? super V,? super V,? extends V> remappingFunction) 如果指定的键尚未与值关联或与null关联，则将其与给定的非空值关联。 |
|  V                    |  put(K key, V value) 将指定的值与此映射中的指定键相关联。    |
|  void                 |  putAll(Map<? extends K,? extends V> m) 将指定映射中的所有映射复制到此映射。 |
|  V                    |  putIfAbsent(K key, V value) 如果指定的键尚未与值相关联（或映射到 null ），则将其与给定值相关联并返回  null ，否则返回当前值。 |
|  V                    |  remove(Object key) 从此映射中删除指定键的映射（如果存在）。 |
|  boolean              |  remove(Object key, Object value) 仅当指定键当前映射到指定值时才删除该条目的条目。 |
|  V                    |  replace(K key, V value) 仅当指定键当前映射到某个值时才替换该条目的条目。 |
|  boolean              |  replace(K key, V oldValue, V newValue) 仅当前映射到指定值时，才替换指定键的条目。 |
|  void                 |  replaceAll(BiFunction<? super K,? super V,? extends V> function) 将每个条目的值替换为在该条目上调用给定函数的结果，直到所有条目都已处理或函数抛出异常。 |
|  int                  |  size() 返回此映射中键 - 值映射的数量。                      |
|  Collection<V>        |  values() 返回[ Collection ](https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html)此映射中包含的值的视图。 |

### 3.TreeMap

#### 1、构造函数摘要

|                构造函数和                 | 描述                                                         |
| :---------------------------------------: | ------------------------------------------------------------ |
|                 TreeMap()                 | 使用其键的自然顺序构造一个新的空树图。                       |
| TreeMap(Comparator<? super K> comparator) | 构造一个新的空树图，根据给定的比较器排序。                   |
|  TreeMap(Map<? extends K,? extends V> m)  | 构造一个包含与给定映射相同映射的新树映射，根据其键的*自然顺序排序*。 |
|    TreeMap(SortedMap<K,? extends V> m)    | 构造一个包含相同映射的新树映射，并使用与指定有序映射相同的顺序。 |

#### 2、常见API

| 修饰符和类型            | 方法和描述                                                   |
| ----------------------- | ------------------------------------------------------------ |
|  Map.Entry<K,V>         |  ceilingEntry(K key) 返回与大于或等于给定键的最小键关联的键 - 值映射，或者 null 如果没有这样的键。 |
|  K                      |  ceilingKey(K key) 返回大于或等于给定键的最小键，或者 null 如果没有这样的键。 |
|  void                   |  clear() 从此映射中删除所有映射。                            |
|  Object                 |  clone() 返回此 TreeMap 实例的浅表副本。                     |
|  Comparator<? super K>  |  comparator() 返回用于对此映射中的键进行排序的比较器，或者  null 此映射是否使用其键的[自然顺序](https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html)。 |
|  boolean                |  containsKey(Object key)  true 如果此映射包含指定键的映射，则返回。 |
|  boolean                |  containsValue(Object value) 返回 true 如果此映射将一个或多个键映射到指定值。 |
|  NavigableSet<K>        |  descendingKeySet() 返回[ NavigableSet ](https://docs.oracle.com/javase/8/docs/api/java/util/NavigableSet.html)此映射中包含的键的逆序视图。 |
|  NavigableMap<K,V>      |  descendingMap() 返回此映射中包含的映射的逆序视图。          |
|  Set<Map.Entry<K,V>>    |  entrySet() 返回[ Set ](https://docs.oracle.com/javase/8/docs/api/java/util/Set.html)此映射中包含的映射的视图。 |
|  Map.Entry<K,V>         |  firstEntry() 返回与此映射中的最小键关联的键 - 值映射，或者 null 如果映射为空。 |
|  K                      |  firstKey() 返回此映射中当前的第一个（最低）键。             |
|  Map.Entry<K,V>         |  floorEntry(K key) 返回与小于或等于给定键的最大键相关联的键 - 值映射，或者 null 如果没有这样的键。 |
|  K                      |  floorKey(K key) 返回小于或等于给定键的最大键，或者 null 如果没有这样的键。 |
|  void                   |  forEach(BiConsumer<? super K,? super V> action) 对此映射中的每个条目执行给定操作，直到处理完所有条目或操作引发异常。 |
|  V                      |  get(Object key) 返回指定键映射到的值，或者 null 此映射是否不包含键的映射。 |
|  SortedMap<K,V>         |  headMap(K toKey) 返回此映射部分的视图，其键严格小于 toKey 。 |
|  NavigableMap<K,V>      |  headMap(K toKey, boolean inclusive) 返回此映射的部分视图，其键小于（或等于，如果 inclusive 为true） toKey 。 |
|  Map.Entry<K,V>         |  higherEntry(K key) 返回与严格大于给定键的最小键关联的键 - 值映射，或者 null 如果没有这样的键。 |
|  K                      |  higherKey(K key) 返回严格大于给定键的最小键，或者  null 如果没有这样的键。 |
|  Set<K>                 |  keySet() 返回[ Set ](https://docs.oracle.com/javase/8/docs/api/java/util/Set.html)此映射中包含的键的视图。 |
|  Map.Entry<K,V>         |  lastEntry() 返回与此映射中的最大键关联的键 - 值映射，或者 null 如果映射为空。 |
|  K                      |  lastKey() 返回此映射中当前的最后一个（最高）键。            |
|  Map.Entry<K,V>         |  lowerEntry(K key) 返回与严格小于给定键的最大键相关联的键 - 值映射，或者 null 如果没有这样的键。 |
|  K                      |  lowerKey(K key) 返回严格小于给定键的最大键，或者  null 如果没有这样的键。 |
|  NavigableSet<K>        |  navigableKeySet() 返回[ NavigableSet ](https://docs.oracle.com/javase/8/docs/api/java/util/NavigableSet.html)此映射中包含的键的视图。 |
|  Map.Entry<K,V>         |  pollFirstEntry() 删除并返回与此映射中的最小键关联的键 - 值映射，或者 null 如果映射为空。 |
|  Map.Entry<K,V>         |  pollLastEntry() 删除并返回与此映射中的最大键关联的键 - 值映射，或者 null 如果映射为空。 |
|  V                      |  put(K key, V value) 将指定的值与此映射中的指定键相关联。    |
|  void                   |  putAll(Map<? extends K,? extends V> map) 将指定映射中的所有映射复制到此映射。 |
|  V                      |  remove(Object key) 如果存在，则从此TreeMap中删除此键的映射。 |
|  V                      |  replace(K key, V value) 仅当指定键当前映射到某个值时才替换该条目的条目。 |
|  boolean                |  replace(K key, V oldValue, V newValue) 仅当前映射到指定值时，才替换指定键的条目。 |
|  void                   |  replaceAll(BiFunction<? super K,? super V,? extends V> function) 将每个条目的值替换为在该条目上调用给定函数的结果，直到所有条目都已处理或函数抛出异常。 |
|  int                    |  size() 返回此映射中键 - 值映射的数量。                      |
|  NavigableMap<K,V>      |  subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) 返回此映射部分的视图，其键的范围  fromKey 为 toKey 。 |
|  SortedMap<K,V>         |  subMap(K fromKey, K toKey) 返回此映射部分的视图，其键的范围从  fromKey （包括）到 toKey 独占。 |
|  SortedMap<K,V>         |  tailMap(K fromKey) 返回此键的大于或等于的部分的视图 fromKey 。 |
|  NavigableMap<K,V>      |  tailMap(K fromKey, boolean inclusive) 返回此映射部分的视图，其键大于（或等于，如果 inclusive 为true） fromKey 。 |
|  Collection<V>          |  values() 返回[ Collection ](https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html)此映射中包含的值的视图。 |

### 4. Map与Set 的关系

1. 都有几个类型的集合。HashMap 和 HashSet ，都采 哈希表算法；TreeMap 和 TreeSet 都采用 红-黑树算法；LinkedHashMap 和 LinkedHashSet 都采用 哈希表算法和红-黑树算法。

2. 分析 Set 的底层源码，我们可以看到，Set 集合 就是 由 Map 集合的 Key 组成。

　　　　　　　　![img](https://images2015.cnblogs.com/blog/1120165/201705/1120165-20170509223239738-2032105541.png)



## 七. 集合重要问题和答案

​	Java集合框架为Java编程语言的基础，也是Java面试中很重要的一个知识点。下面列出了一些关于Java集合的重要问题和答案。

1.Java集合框架是什么？说出一些集合框架的优点？

    	每种编程语言中都有集合，最初的Java版本包含几种集合类：Vector、Stack、HashTable和Array。随着集合的广泛使用，Java1.2提出了囊括所有集合接口、实现和算法的集合框架。在保证线程安全的情况下使用泛型和并发集合类，Java已经经历了很久。它还包括在Java并发包中，阻塞接口以及它们的实现。集合框架的部分优点如下：
    	
    	1）使用核心集合类降低开发成本，而非实现我们自己的集合类。
    	2）随着使用经过严格测试的集合框架类，代码质量会得到提高。
    	3）通过使用JDK附带的集合类，可以降低代码维护成本。
    	4）复用性和可操作性。

2.集合框架中的泛型有什么优点？

    	Java1.5引入了泛型，所有的集合接口和实现都大量地使用它。泛型允许我们为集合提供一个可以容纳的对象类型，因此，如果你添加其它类型的任何元素，它会在编译时报错。这避免了在运行时出现ClassCastException，因为你将会在编译时得到报错信息。泛型也使得代码整洁，我们不需要使用显式转换和instanceOf操作符。它也给运行时带来好处，因为不会产生类型检查的字节码指令。

3.Java集合框架的基础接口有哪些？

        Collection为集合层级的根接口。一个集合代表一组对象，这些对象即为它的元素。Java平台不提供这个接口任何直接的实现。
    
        Set是一个不能包含重复元素的集合。这个接口对数学集合抽象进行建模，被用来代表集合，就如一副牌。
    
        List是一个有序集合，可以包含重复元素。你可以通过它的索引来访问任何元素。List更像长度动态变换的数组。
    
        Map是一个将key映射到value的对象.一个Map不能包含重复的key：每个key最多只能映射一个value。
    
        一些其它的接口有Queue、Dequeue、SortedSet、SortedMap和ListIterator。

4.为何Collection不从Cloneable和Serializable接口继承？

        Collection接口指定一组对象，对象即为它的元素。如何维护这些元素由Collection的具体实现决定。例如，一些如List的Collection实现允许重复的元素，而其它的如Set就不允许。很多Collection实现有一个公有的clone方法。然而，把它放到集合的所有实现中也是没有意义的。这是因为Collection是一个抽象表现。重要的是实现。
    
        当与具体实现打交道的时候，克隆或序列化的语义和含义才发挥作用。所以，具体实现应该决定如何对它进行克隆或序列化，或它是否可以被克隆或序列化。
    
        在所有的实现中授权克隆和序列化，最终导致更少的灵活性和更多的限制。特定的实现应该决定它是否可以被克隆和序列化。

5.为何Map接口不继承Collection接口？

        尽管Map接口和它的实现也是集合框架的一部分，但Map不是集合，集合也不是Map。因此，Map继承Collection毫无意义，反之亦然。
    
        如果Map继承Collection接口，那么元素去哪儿？Map包含key-value对，它提供抽取key或value列表集合的方法，但是它不适合“一组对象”规范。

6.Iterator是什么？

        Iterator接口提供遍历任何Collection的接口。我们可以从一个Collection中使用迭代器方法来获取迭代器实例。迭代器取代了Java集合框架中的Enumeration。迭代器允许调用者在迭代过程中移除元素。

7.Enumeration和Iterator接口的区别？

    	Enumeration的速度是Iterator的两倍，也使用更少的内存。Enumeration是非常基础的，也满足了基础的需要。但是，与Enumeration相比，Iterator更加安全，因为当一个集合正在被遍历的时候，它会阻止其它线程去修改集合。
    	迭代器取代了Java集合框架中的Enumeration。迭代器允许调用者从集合中移除元素，而Enumeration不能做到。为了使它的功能更加清晰，迭代器方法名已经经过改善。

​	

8.为何没有像Iterator.add()这样的方法，向集合中添加元素？

    	语义不明，已知的是，Iterator的协议不能确保迭代的次序。然而要注意，ListIterator没有提供一个add操作，它要确保迭代的顺序。

9.为何迭代器没有一个方法可以直接获取下一个元素，而不需要移动游标？

    	它可以在当前Iterator的顶层实现，但是它用得很少，如果将它加到接口中，每个继承都要去实现它，这没有意义。

10.Iterater 和 ListIterator之间有什么区别？

```
	1）我们可以使用Iterator来遍历Set和List集合，而ListIterator只能遍历List。

	2）Iterator只可以向前遍历，而ListIterator可以双向遍历。

	3）ListIterator从Iterator接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。
```

11.遍历一个List有哪些不同的方式？

```java
    List<String> strList = new ArrayList<>();
    //使用for-each循环
    for(String obj : strList){
    	System.out.println(obj);
    }
    //using iterator
    Iterator<String> it = strList.iterator();
    while(it.hasNext()){
      	String obj = it.next();
      	System.out.println(obj);
    }

	使用迭代器更加线程安全，因为它可以确保，在当前遍历的集合元素被更改的时候，它会抛出ConcurrentModificationException。
```

12.通过迭代器fail-fast属性，你明白了什么？

    	每次我们尝试获取下一个元素的时候，Iterator fail-fast属性检查当前集合结构里的任何改动。如果发现任何改动，它抛出ConcurrentModificationException。Collection中所有Iterator的实现都是按fail-fast来设计的（ConcurrentHashMap和CopyOnWriteArrayList这类并发集合类除外）。

13.fail-fast与fail-safe有什么区别？

    	Iterator的fail-fast属性与当前的集合共同起作用，因此它不会受到集合中任何改动的影响。Java.util包中的所有集合类都被设计为fail-fast的，而java.util.concurrent中的集合类都为fail-safe的。Fail-fast迭代器抛出ConcurrentModificationException，而fail-safe迭代器从不抛出ConcurrentModificationException。

14.在迭代一个集合的时候，如何避免ConcurrentModificationException？

    	在遍历一个集合的时候，我们可以使用并发集合类来避免ConcurrentModificationException，比如使用CopyOnWriteArrayList，而不是ArrayList。

15.为何Iterator接口没有具体的实现？

    	Iterator接口定义了遍历集合的方法，但它的实现则是集合实现类的责任。每个能够返回用于遍历的Iterator的集合类都有它自己的Iterator实现内部类。
    	这就允许集合类去选择迭代器是fail-fast还是fail-safe的。比如，ArrayList迭代器是fail-fast的，而CopyOnWriteArrayList迭代器是fail-safe的。

16.UnsupportedOperationException是什么？

    	UnsupportedOperationException是用于表明操作不支持的异常。在JDK类中已被大量运用，在集合框架java.util.Collections.UnmodifiableCollection将会在所有add和remove操作中抛出这个异常。

17.在Java中，HashMap是如何工作的？

        HashMap在Map.Entry静态内部类实现中存储key-value对。HashMap使用哈希算法，在put和get方法中，它使用hashCode()和equals()方法。当我们通过传递key-value对调用put方法的时候，HashMap使用Key hashCode()和哈希算法来找出存储key-value对的索引。Entry存储在LinkedList中，所以如果存在entry，它使用equals()方法来检查传递的key是否已经存在，如果存在，它会覆盖value，如果不存在，它会创建一个新的entry然后保存。当我们通过传递key调用get方法时，它再次使用hashCode()来找到数组中的索引，然后使用equals()方法找出正确的Entry，然后返回它的值。下面的图片解释了详细内容。
    
        其它关于HashMap比较重要的问题是容量、负荷系数和阀值调整。HashMap默认的初始容量是32，负荷系数是0.75。阀值是为负荷系数乘以容量，无论何时我们尝试添加一个entry，如果map的大小比阀值大的时候，HashMap会对map的内容进行重新哈希，且使用更大的容量。容量总是2的幂，所以如果你知道你需要存储大量的key-value对，比如缓存从数据库里面拉取的数据，使用正确的容量和负荷系数对HashMap进行初始化是个不错的做法。

18.hashCode()和equals()方法有何重要性？

    	HashMap使用Key对象的hashCode()和equals()方法去决定key-value对的索引。当我们试着从HashMap中获取值的时候，这些方法也会被用到。如果这些方法没有被正确地实现，在这种情况下，两个不同Key也许会产生相同的hashCode()和equals()输出，HashMap将会认为它们是相同的，然后覆盖它们，而非把它们存储到不同的地方。同样的，所有不允许存储重复数据的集合类都使用hashCode()和equals()去查找重复，所以正确实现它们非常重要。equals()和hashCode()的实现应该遵循以下规则：
    	
    	1）如果o1.equals(o2)，那么o1.hashCode() == o2.hashCode()总是为true的。
    	2）如果o1.hashCode() == o2.hashCode()，并不意味着o1.equals(o2)会为true。

19.我们能否使用任何类作为Map的key？

    	我们可以使用任何类作为Map的key，然而在使用它们之前，需要考虑以下几点：
    	
    	1）如果类重写了equals()方法，它也应该重写hashCode()方法。
    	2）类的所有实例需要遵循与equals()和hashCode()相关的规则。请参考之前提到的这些规则。
    	3）如果一个类没有使用equals()，你不应该在hashCode()中使用它。
    	4）用户自定义key类的最佳实践是使之为不可变的，这样，hashCode()值可以被缓存起来，拥有更好的性能。不可变的类也可以确保hashCode()和equals()在未来不会改变，这样就会解决与可变相关的问题了。

```java
	比如，我有一个类MyKey，在HashMap中使用它。
	//传递给MyKey的name参数被用于equals()和hashCode()中
    MyKey key = new MyKey('Pankaj'); //assume hashCode=1234
    myHashMap.put(key, 'Value');
    // 以下的代码会改变key的hashCode()和equals()值
    key.setName('Amit'); //assume new hashCode=7890
    //下面会返回null，因为HashMap会尝试查找存储同样索引的key，而key已被改变了，匹配失败，返回null
    myHashMap.get(new MyKey('Pankaj'));
   那就是为何String和Integer被作为HashMap的key大量使用。
```

20.Map接口提供了哪些不同的集合视图？

        Map接口提供三个集合视图：
        1）Set keyset()：返回map中包含的所有key的一个Set视图。集合是受map支持的，map的变化会在集合中反映出来，反之亦然。当一个迭代器正在遍历一个集合时，若map被修改了（除迭代器自身的移除操作以外），迭代器的结果会变为未定义。集合支持通过Iterator的Remove、Set.remove、removeAll、retainAll和clear操作进行元素移除，从map中移除对应的映射。它不支持add和addAll操作。
    
        2）Collection values()：返回一个map中包含的所有value的一个Collection视图。这个collection受map支持的，map的变化会在collection中反映出来，反之亦然。当一个迭代器正在遍历一个collection时，若map被修改了（除迭代器自身的移除操作以外），迭代器的结果会变为未定义。集合支持通过Iterator的Remove、Set.remove、removeAll、retainAll和clear操作进行元素移除，从map中移除对应的映射。它不支持add和addAll操作。
    
        3）Set<Map.Entry<K,V>> entrySet()：返回一个map钟包含的所有映射的一个集合视图。这个集合受map支持的，map的变化会在collection中反映出来，反之亦然。当一个迭代器正在遍历一个集合时，若map被修改了（除迭代器自身的移除操作，以及对迭代器返回的entry进行setValue外），迭代器的结果会变为未定义。集合支持通过Iterator的Remove、Set.remove、removeAll、retainAll和clear操作进行元素移除，从map中移除对应的映射。它不支持add和addAll操作。	

21.HashMap和HashTable有何不同？

```
    1）HashMap允许key和value为null，而HashTable不允许。

    2）HashTable是同步的，而HashMap不是。所以HashMap适合单线程环境，HashTable适合多线程环境。

    3）在Java1.4中引入了LinkedHashMap，HashMap的一个子类，假如你想要遍历顺序，你很容易从HashMap转向LinkedHashMap，但是HashTable不是这样的，它的顺序是不可预知的。

    4）HashMap提供对key的Set进行遍历，因此它是fail-fast的，但HashTable提供对key的Enumeration进行遍历，它不支持fail-fast。

    5）HashTable被认为是个遗留的类，如果你寻求在迭代的时候修改Map，你应该使用CocurrentHashMap。
```

22.如何决定选用HashMap还是TreeMap？

    	对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。

23.ArrayList和Vector有何异同点？

        ArrayList和Vector在很多时候都很类似。
        1）两者都是基于索引的，内部由一个数组支持。
    
        2）两者维护插入的顺序，我们可以根据插入顺序来获取元素。
    
        3）ArrayList和Vector的迭代器实现都是fail-fast的。
    
        4）ArrayList和Vector两者允许null值，也可以使用索引值对元素进行随机访问。
    
        以下是ArrayList和Vector的不同点。
        1）Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。
    
        2）ArrayList比Vector快，它因为有同步，不会过载。
    
        3）ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。

24.Array和ArrayList有何区别？什么时候更适合用Array？

        Array可以容纳基本类型和对象，而ArrayList只能容纳对象。
    
        Array是指定大小的，而ArrayList大小是固定的。
    
        Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。尽管ArrayList明显是更好的选择，但也有些时候Array比较好用。
    
        1）如果列表的大小已经指定，大部分情况下是存储和遍历它们。
    
        2）对于遍历基本数据类型，尽管Collections使用自动装箱来减轻编码任务，在指定大小的基本类型的列表上工作也会变得很慢。
    
        3）如果你要使用多维数组，使用[][]比List<List<>>更容易。

25.ArrayList和LinkedList有何区别？

        ArrayList和LinkedList两者都实现了List接口，但是它们之间有些不同。
        1）ArrayList是由Array所支持的基于一个索引的数据结构，所以它提供对元素的随机访问，复杂度为O(1)，但LinkedList存储一系列的节点数据，每个节点都与前一个和下一个节点相连接。所以，尽管有使用索引获取元素的方法，内部实现是从起始点开始遍历，遍历到索引的节点然后返回元素，时间复杂度为O(n)，比ArrayList要慢。
    
        2）与ArrayList相比，在LinkedList中插入、添加和删除一个元素会更快，因为在一个元素被插入到中间的时候，不会涉及改变数组的大小，或更新索引。
    
        3）LinkedList比ArrayList消耗更多的内存，因为LinkedList中的每个节点存储了前后节点的引用。

26.哪些集合类提供对元素的随机访问？

    ArrayList、HashMap、TreeMap和HashTable类提供对元素的随机访问。

27.EnumSet是什么？

        java.util.EnumSet是使用枚举类型的集合实现。当集合创建时，枚举集合中的所有元素必须来自单个指定的枚举类型，可以是显示的或隐示的。EnumSet是不同步的，不允许值为null的元素。它也提供了一些有用的方法，比如copyOf(Collection c)、of(E first,E…rest)和complementOf(EnumSet s)。

28.哪些集合类是线程安全的？

    	Vector、HashTable、Properties和Stack是同步类，所以它们是线程安全的，可以在多线程环境下使用。Java1.5并发API包括一些集合类，允许迭代时修改，因为它们都工作在集合的克隆上，所以它们在多线程环境中是安全的。

29.并发集合类是什么？

    	Java1.5并发包（java.util.concurrent）包含线程安全集合类，允许在迭代时修改集合。迭代器被设计为fail-fast的，会抛出ConcurrentModificationException。一部分类为：CopyOnWriteArrayList、 ConcurrentHashMap、CopyOnWriteArraySet。

30.BlockingQueue是什么？

    Java.util.concurrent.BlockingQueue是一个队列，在进行检索或移除一个元素的时候，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。BlockingQueue接口是Java集合框架的一部分，主要用于实现生产者-消费者模式。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。Java提供了集中BlockingQueue的实现，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。

31.队列和栈是什么，列出它们的区别？

    	栈和队列两者都被用来预存储数据。java.util.Queue是一个接口，它的实现类在Java并发包中。队列允许先进先出（FIFO）检索元素，但并非总是这样。Deque接口允许从两端检索元素。
    	栈与队列很相似，但它允许对元素进行后进先出（LIFO）进行检索。
    	
    	Stack是一个扩展自Vector的类，而Queue是一个接口。

32.Collections类是什么？

    	Java.util.Collections是一个工具类仅包含静态方法，它们操作或返回集合。它包含操作集合的多态算法，返回一个由指定集合支持的新集合和其它一些内容。这个类包含集合框架算法的方法，比如折半搜索、排序、混编和逆序等。

33.Comparable和Comparator接口是什么？

    	如果我们想使用Array或Collection的排序方法时，需要在自定义类里实现Java提供Comparable接口。Comparable接口有compareTo(T OBJ)方法，它被排序方法所使用。我们应该重写这个方法，如果“this”对象比传递的对象参数更小、相等或更大时，它返回一个负整数、0或正整数。但是，在大多数实际情况下，我们想根据不同参数进行排序。比如，作为一个CEO，我想对雇员基于薪资进行排序，一个HR想基于年龄对他们进行排序。这就是我们需要使用Comparator接口的情景，因为Comparable.compareTo(Object o)方法实现只能基于一个字段进行排序，我们不能根据对象排序的需要选择字段。Comparator接口的compare(Object o1, Object o2)方法的实现需要传递两个对象参数，若第一个参数比第二个小，返回负整数；若第一个等于第二个，返回0；若第一个比第二个大，返回正整数。

34.Comparable和Comparator接口有何区别？

    	Comparable和Comparator接口被用来对对象集合或者数组进行排序。Comparable接口被用来提供对象的自然排序，我们可以使用它来提供基于单个逻辑的排序。
    
    	Comparator接口被用来提供不同的排序算法，我们可以选择需要使用的Comparator来对给定的对象集合进行排序。

35.我们如何对一组对象进行排序？

    	如果我们需要对一个对象数组进行排序，我们可以使用Arrays.sort()方法。如果我们需要排序一个对象列表，我们可以使用Collection.sort()方法。两个类都有用于自然排序（使用Comparable）或基于标准的排序（使用Comparator）的重载方法sort()。Collections内部使用数组排序方法，所有它们两者都有相同的性能，只是Collections需要花时间将列表转换为数组。

36.当一个集合被作为参数传递给一个函数时，如何才可以确保函数不能修改它？

    	在作为参数传递之前，我们可以使用Collections.unmodifiableCollection(Collection c)方法创建一个只读集合，这将确保改变集合的任何操作都会抛出UnsupportedOperationException。

37.我们如何从给定集合那里创建一个synchronized的集合？

    	我们可以使用Collections.synchronizedCollection(Collection c)根据指定集合来获取一个synchronized（线程安全的）集合。

38.集合框架里实现的通用算法有哪些？

    	Java集合框架提供常用的算法实现，比如排序和搜索。Collections类包含这些方法实现。大部分算法是操作List的，但一部分对所有类型的集合都是可用的。部分算法有排序、搜索、混编、最大最小值。

39.大写的O是什么？举几个例子？

    	大写的O描述的是，就数据结构中的一系列元素而言，一个算法的性能。Collection类就是实际的数据结构，我们通常基于时间、内存和性能，使用大写的O来选择集合实现。比如：例子1：ArrayList的get(index i)是一个常量时间操作，它不依赖list中元素的数量。所以它的性能是O(1)。例子2：一个对于数组或列表的线性搜索的性能是O(n)，因为我们需要遍历所有的元素来查找需要的元素。

40.与Java集合框架相关的有哪些最好的实践？

```
    1）根据需要选择正确的集合类型。比如，如果指定了大小，我们会选用Array而非ArrayList。如果我们想根据插入顺序遍历一个Map，我们需要使用TreeMap。如果我们不想重复，我们应该使用Set。

    2）一些集合类允许指定初始容量，所以如果我们能够估计到存储元素的数量，我们可以使用它，就避免了重新哈希或大小调整。

    3）基于接口编程，而非基于实现编程，它允许我们后来轻易地改变实现。

    4）总是使用类型安全的泛型，避免在运行时出现ClassCastException。

    5）使用JDK提供的不可变类作为Map的key，可以避免自己实现hashCode()和equals()。

    6）尽可能使用Collections工具类，或者获取只读、同步或空的集合，而非编写自己的实现。它将会提供代码重用性，它有着更好的稳定性和可维护性。
```

